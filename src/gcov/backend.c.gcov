        -:    0:Source:brick_game/tetris/backend.c
        -:    1:#include "backend.h"
        -:    2:
        -:    3:#include "../../gui/cli/frontend.h"
        -:    4:
        -:    5:static FSMState transitionMatrix[NUM_STATES][8] = {
        -:    6:    [START] = {[Start] = SPAWN,
        -:    7:               [Terminate] = GAME_OVER,
        -:    8:               [Pause] = START,
        -:    9:               [Left] = START,
        -:   10:               [Right] = START,
        -:   11:               [Up] = START,
        -:   12:               [Down] = START,
        -:   13:               [Action] = START},
        -:   14:    [SPAWN] = {[Action] = MOVING,
        -:   15:               [Terminate] = GAME_OVER,
        -:   16:               [Pause] = SPAWN,
        -:   17:               [Left] = SPAWN,
        -:   18:               [Right] = SPAWN,
        -:   19:               [Up] = SPAWN,
        -:   20:               [Down] = SPAWN,
        -:   21:               [Start] = SPAWN},
        -:   22:    [MOVING] = {[Action] = SHIFTING,
        -:   23:                [Terminate] = GAME_OVER,
        -:   24:                [Pause] = MOVING,
        -:   25:                [Left] = MOVING,
        -:   26:                [Right] = MOVING,
        -:   27:                [Up] = MOVING,
        -:   28:                [Down] = MOVING,
        -:   29:                [Start] = MOVING},
        -:   30:    [SHIFTING] = {[Action] = SHIFTING,
        -:   31:                  [Terminate] = GAME_OVER,
        -:   32:                  [Pause] = MOVING,
        -:   33:                  [Left] = MOVING,
        -:   34:                  [Right] = MOVING,
        -:   35:                  [Up] = MOVING,
        -:   36:                  [Down] = MOVING,
        -:   37:                  [Start] = START},
        -:   38:    [ATTACHING] = {[Action] = SPAWN,
        -:   39:                   [Terminate] = GAME_OVER,
        -:   40:                   [Pause] = ATTACHING,
        -:   41:                   [Left] = ATTACHING,
        -:   42:                   [Right] = ATTACHING,
        -:   43:                   [Up] = ATTACHING,
        -:   44:                   [Down] = ATTACHING,
        -:   45:                   [Start] = ATTACHING},
        -:   46:    [GAME_OVER] = {[Action] = GAME_OVER,
        -:   47:                   [Terminate] = GAME_OVER,
        -:   48:                   [Pause] = GAME_OVER,
        -:   49:                   [Left] = GAME_OVER,
        -:   50:                   [Right] = GAME_OVER,
        -:   51:                   [Up] = GAME_OVER,
        -:   52:                   [Down] = GAME_OVER,
        -:   53:                   [Start] = START}};
        -:   54:
        -:   55:
        2:   56:int tetris_start() {
        2:   57:  int res = 0;
        2:   58:  Singleton *s = get_instance();
        2:   59:  s->state = SPAWN;
        2:   60:  res = initialize_game();
        2:   61:  int ch = '\0';
        2:   62:  int pocket = '\0';
        2:   63:  bool hold = false;
        2:   64:  clock_t last_update_time = clock();
        2:   65:  nodelay(stdscr, TRUE);
        4:   66:  while (s->state != GAME_OVER) {
        2:   67:    change_speed();
        2:   68:    clock_t current_time = clock();
        2:   69:    if (tet_timer(&current_time, &last_update_time, s->game.speed)) {
    #####:   70:      if (!s->game.pause) {
    #####:   71:        update_field(updateCurrentState());
        -:   72:      }
    #####:   73:      last_update_time = current_time;
        -:   74:    }
        2:   75:    userInput(keyboard_action(&ch, &pocket, &hold, false), hold);
        2:   76:    refresh();
        2:   77:    if (s->test==1) s->state=GAME_OVER;
        -:   78:  }
        2:   79:  nodelay(stdscr, FALSE);
        2:   80:  return res;
        -:   81:}
        -:   82:
        4:   83:GameInfo_t updateCurrentState() {
        4:   84:  Singleton *s = get_instance();
        4:   85:  int ch = '\0';
        4:   86:  bool hold = false;
        4:   87:  int pocket = '\0';
        4:   88:  s->action = keyboard_action(&ch, &pocket, &hold, false);
        4:   89:  userInput(s->action, hold);
        4:   90:  if (s->action > 0 && s->action <= 8) {
    #####:   91:    s->state = transitionMatrix[s->state][s->action];
        -:   92:  }
        4:   93:  switch (s->state) {
        1:   94:    case SPAWN:
        1:   95:      init_piece();
        1:   96:      s->state = MOVING;
        1:   97:      break;
        1:   98:    case MOVING:
        1:   99:      move_piece_down();
        1:  100:      s->state= MOVING;
        1:  101:      break;
        1:  102:    case ATTACHING:
        1:  103:      if (check_collision_end_game()) {
    #####:  104:        s->state= GAME_OVER;
        -:  105:      } else {
        1:  106:        attach_piece_to_field();
        1:  107:        check_for_complete_lines();
        1:  108:        s->state= SPAWN;
        -:  109:      }
        1:  110:      break;
        1:  111:    default:
        1:  112:      break;
        -:  113:  }
        4:  114:  return s->game;
        -:  115:}
        -:  116:
        6:  117:int initialize_game() {
        6:  118:  int res = 0;
        6:  119:  Singleton *s = get_instance();
        6:  120:  s->game.field = (int **)calloc(HEIGHT, sizeof(int *));
        6:  121:  if (!s->game.field) {
    #####:  122:    perror("Failed to allocate memory for game.field");
    #####:  123:    res++;
        -:  124:  }
      126:  125:  for (int i = 0; i < HEIGHT && !res; i++) {
      120:  126:    s->game.field[i] = (int *)calloc(WIDTH, sizeof(int));
      120:  127:    if (!s->game.field[i]) {
    #####:  128:      perror("Failed to allocate memory for game.field[i]");
    #####:  129:      res++;
        -:  130:    }
        -:  131:  }
        6:  132:  if (!res) {
        6:  133:    s->game.next = (int **)calloc(4, sizeof(int *));
        6:  134:    if (!s->game.next) {
    #####:  135:      perror("Failed to allocate memory for game.next");
    #####:  136:      res++;
        -:  137:    }
       30:  138:    for (int i = 0; i < 4 && !res; i++) {
       24:  139:      s->game.next[i] = (int *)calloc(4, sizeof(int));
       24:  140:      if (!s->game.next[i]) {
    #####:  141:        perror("Failed to allocate memory for game.next[i]");
    #####:  142:        res++;
        -:  143:      }
        -:  144:    }
        -:  145:  }
        6:  146:  s->game.score = 0;
        6:  147:  s->game.high_score = read_high_score();
        6:  148:  s->game.level = 0;
        6:  149:  s->game.speed = 8000;
        6:  150:  init_piece();
        6:  151:  return res;
        -:  152:}
        -:  153:
        2:  154:bool tet_timer(clock_t *current_time, clock_t *last_update_time, int speed) {
        2:  155:  return (((*current_time - *last_update_time) * 10000 / CLOCKS_PER_SEC) >=
        -:  156:          speed);
        -:  157:}
        -:  158:
        2:  159:int play_tetris(int ch) {
        2:  160:  Singleton * s =get_instance();
        2:  161:  s->test = (ch == 1) ? 0 : 1;
        2:  162:  clear();
        2:  163:  int menu_start_x = (WIDTH * 2) / 2 - 3;
        2:  164:  int menu_start_y = HEIGHT / 2 - 2 / 2;
        2:  165:  draw_board();
        2:  166:  int high_score = read_high_score();
        2:  167:  draw_score(0, high_score, 0);
        2:  168:  int x_cooord = 17;
        2:  169:  mvprintw(menu_start_y, menu_start_x - 1, "Tetris game");
        2:  170:  mvprintw(menu_start_y + 2, menu_start_x - 5, "Press \"S\" for Start");
        2:  171:  mvprintw(menu_start_y - 1, menu_start_x + x_cooord, "Press \"P\" for Pause");
        2:  172:  mvprintw(menu_start_y + 1, menu_start_x + x_cooord,
        -:  173:           "Press \"Down\" for Down");
        2:  174:  mvprintw(menu_start_y + 3, menu_start_x + x_cooord,
        -:  175:           "Press \"Left\" for Left");
        2:  176:  mvprintw(menu_start_y + 5, menu_start_x + x_cooord,
        -:  177:           "Press \"Right\" for Right");
        2:  178:  mvprintw(menu_start_y + 7, menu_start_x + x_cooord,
        -:  179:           "Press \"Space\" for Action");
        2:  180:  mvprintw(menu_start_y + 9, menu_start_x + x_cooord, "Press \"Q\" for Quit");
       2*:  181:  while (ch != 'S' && ch != 's') {
    #####:  182:    ch = GET_USER_INPUT;
        -:  183:  }
        2:  184:  int res = tetris_start();
        2:  185:  if (s->test!=1){
    #####:  186:  game_over_menu();
        -:  187: }
        2:  188:  free_game_resources();
        2:  189:  free_singleton();
        2:  190:  return res;
        -:  191:}
        3:  192:void free_game_resources() {
        3:  193:  Singleton *s = get_instance();
        3:  194:  if (s->game.field != NULL) {
       42:  195:    for (int i = 0; i < HEIGHT; i++) {
       40:  196:      if (s->game.field[i] != NULL) {
       40:  197:        free(s->game.field[i]);
        -:  198:      }
        -:  199:    }
        2:  200:    free(s->game.field);
        2:  201:    s->game.field = NULL;
        -:  202:  }
        3:  203:  if (s->game.next != NULL) {
       10:  204:    for (int i = 0; i < 4; i++) {
        8:  205:      if (s->game.next[i] != NULL) {
        8:  206:        free(s->game.next[i]);
        -:  207:      }
        -:  208:    }
        2:  209:    free(s->game.next);
        2:  210:    s->game.next = NULL;
        -:  211:  }
        3:  212:}
        7:  213:void init_piece() {
        7:  214:  Singleton *s = get_instance();
        -:  215:  struct timespec tv;
        7:  216:  clock_gettime(CLOCK_MONOTONIC, &tv);
        7:  217:  unsigned int seed = tv.tv_sec * 1000000 + tv.tv_nsec / 1000;
        7:  218:  srand(seed);
        -:  219:  // Инициализация новой фигуры в верхней части экрана
        7:  220:  s->current_piece.x = WIDTH / 2 - 2;
        7:  221:  s->current_piece.y = 0;
        -:  222:  // Определение различных форм фигур
        7:  223:  int shapes[7][4][4] = SHAPES;
        -:  224:  // Инициализация генератора случайных чисел
        7:  225:  srand(time(NULL));
        7:  226:  int shape_next = rand() % 7;
       35:  227:  for (int i = 0; i < 4; i++) {
      140:  228:    for (int j = 0; j < 4; j++) {
      112:  229:      s->game.next[i][j] = shapes[shape_next][i][j];
        -:  230:    }
        -:  231:  }
        7:  232:  if (s->shape_curr == -1) {
        6:  233:    s->shape_curr = rand() % 7;
        -:  234:  }
        7:  235:  memcpy(s->current_piece.shape, shapes[s->shape_curr],
        -:  236:         sizeof(shapes[s->shape_curr]));
        7:  237:  s->current_piece.type = s->shape_curr;
        7:  238:  s->shape_curr = shape_next;
        7:  239:}
        -:  240:
       21:  241:void move_piece_down() {
       21:  242:  Singleton *s = get_instance();
       21:  243:  s->current_piece.y++;
       21:  244:  if (check_collision()) {
        1:  245:    s->current_piece.y--;
        1:  246:    s->state = ATTACHING;
        -:  247:  }
       21:  248:}
        2:  249:void move_piece_left() {
        2:  250:  Singleton *s = get_instance();
        2:  251:  if (s->state == MOVING) {
        1:  252:    s->current_piece.x--;
        1:  253:    if (check_collision()) {
    #####:  254:      s->current_piece.x++;
        -:  255:    }
        -:  256:  }
        2:  257:}
        -:  258:
        2:  259:void move_piece_right() {
        2:  260:  Singleton *s = get_instance();
        2:  261:  if (s->state == MOVING) {
        1:  262:    s->current_piece.x++;
        1:  263:    if (check_collision()) {
    #####:  264:      s->current_piece.x--;
        -:  265:    }
        -:  266:  }
        2:  267:}
        -:  268:
        1:  269:void move_piece_up() {}
        -:  270:
        2:  271:void rotate_piece() {
        2:  272:  Singleton *s = get_instance();
       2*:  273:  if (s->state == MOVING && s->current_piece.type != 1) {
    #####:  274:    int temp_shape[4][4] = {0};
        -:  275:    // Транспонируем матрицу
    #####:  276:    for (int y = 0; y < 4; y++) {
    #####:  277:      for (int x = 0; x < 4; x++) {
    #####:  278:        temp_shape[x][y] = s->current_piece.shape[y][x];
        -:  279:      }
        -:  280:    }
        -:  281:    // Отражаем матрицу по вертикали
    #####:  282:    for (int y = 0; y < 4; y++) {
    #####:  283:      for (int x = 0; x < 4; x++) {
    #####:  284:        s->current_piece.shape[x][y] = temp_shape[x][3 - y];
        -:  285:      }
        -:  286:    }
        -:  287:    // Проверка коллизий
    #####:  288:    if (check_collision()) {
        -:  289:      // Попробуем сдвинуть фигуру, чтобы она не застревала в стене
    #####:  290:      bool collision = true;
    #####:  291:      for (int dx = -1; dx <= 1 && collision; dx++) {
    #####:  292:        for (int dy = -1; dy <= 1 && collision; dy++) {
    #####:  293:          s->current_piece.x += dx;
    #####:  294:          s->current_piece.y += dy;
    #####:  295:          if (!check_collision()) {
    #####:  296:            collision = false;
    #####:  297:            break;
        -:  298:          }
    #####:  299:          s->current_piece.x -= dx;
    #####:  300:          s->current_piece.y -= dy;
        -:  301:        }
        -:  302:      }
        -:  303:      // Если не удалось избежать коллизий, проверим границы и скорректируем
    #####:  304:      if (collision) {
        -:  305:        // Корректируем положение фигуры относительно границ поля
    #####:  306:        for (int x = 0; x < 4; x++) {
    #####:  307:          for (int y = 0; y < 4; y++) {
    #####:  308:            if (s->current_piece.shape[y][x] != 0) {
    #####:  309:              if (s->current_piece.x + x < 0) {
    #####:  310:                s->current_piece.x++;
        -:  311:              }
    #####:  312:              if (s->current_piece.x + x >= WIDTH) {
    #####:  313:                s->current_piece.x--;
        -:  314:              }
    #####:  315:              if (s->current_piece.y + y >= HEIGHT) {
    #####:  316:                s->current_piece.y--;
        -:  317:              }
        -:  318:            }
        -:  319:          }
        -:  320:        }
        -:  321:        // Повторная проверка коллизий после корректировки
    #####:  322:        if (check_collision()) {
        -:  323:          // Попробуем переместить фигуру только по горизонтали
    #####:  324:          for (int dx = -2; dx <= 2 && collision; dx++) {
    #####:  325:            s->current_piece.x += dx;
    #####:  326:            if (!check_collision()) {
    #####:  327:              collision = false;
    #####:  328:              break;
        -:  329:            }
    #####:  330:            s->current_piece.x -= dx;
        -:  331:          }
        -:  332:          // Если все еще не удалось избежать коллизий, отменяем поворот
    #####:  333:          if (collision) {
    #####:  334:            for (int y = 0; y < 4; y++) {
    #####:  335:              for (int x = 0; x < 4; x++) {
    #####:  336:                s->current_piece.shape[y][x] = temp_shape[y][x];
        -:  337:              }
        -:  338:            }
        -:  339:          }
        -:  340:        }
        -:  341:      }
        -:  342:    }
        -:  343:  }
        2:  344:}
       24:  345:bool check_collision() {
       24:  346:  Singleton *s = get_instance();
      117:  347:  for (int y = 0; y < 4; y++) {
      466:  348:    for (int x = 0; x < 4; x++) {
      373:  349:      if (s->current_piece.shape[y][x] != 0) {
       79:  350:        int new_y = s->current_piece.y + y;
       79:  351:        int new_x = s->current_piece.x + x;
       79:  352:        if (new_y >= HEIGHT || new_x < 0 || new_x >= WIDTH ||
       78:  353:            s->game.field[new_y][new_x] != 0) {
        1:  354:          return true;
        -:  355:        }
        -:  356:      }
        -:  357:    }
        -:  358:  }
       23:  359:  return false;
        -:  360:}
        2:  361:bool check_collision_end_game() {
        2:  362:  Singleton *s = get_instance();
       10:  363:  for (int y = 0; y < 4; y++) {
       40:  364:    for (int x = 0; x < 4; x++) {
       32:  365:      if (s->current_piece.shape[y][x] != 0) {
        4:  366:        int new_y = s->current_piece.y + y;
        4:  367:        int new_x = s->current_piece.x + x;
        -:  368:        // Проверка на выход за границы поля
       4*:  369:        if (new_y >= HEIGHT || new_x < 0 || new_x >= WIDTH) {
    #####:  370:          continue;
        -:  371:        }
        -:  372:        // Проверка на столкновение с уже существующими фигурами
        4:  373:        if (s->game.field[new_y][new_x] != 0) {
    #####:  374:          return true;
        -:  375:        }
        -:  376:      }
        -:  377:    }
        -:  378:  }
        2:  379:  return false;
        -:  380:}
        2:  381:void attach_piece_to_field() {
        2:  382:  Singleton *s = get_instance();
       10:  383:  for (int y = 0; y < 4; y++) {
       40:  384:    for (int x = 0; x < 4; x++) {
       32:  385:      if (s->current_piece.shape[y][x] != 0) {
        4:  386:        int field_y = s->current_piece.y + y;
        4:  387:        int field_x = s->current_piece.x + x;
        4:  388:        if (field_y >= 0 && field_y < HEIGHT && field_x >= 0 &&
        -:  389:            field_x < WIDTH) {
        4:  390:          s->game.field[field_y][field_x] = s->current_piece.shape[y][x];
        -:  391:        }
        -:  392:      }
        -:  393:    }
        -:  394:  }
        2:  395:}
        -:  396:
        1:  397:void check_for_complete_lines() {
        1:  398:  Singleton *s = get_instance();
        1:  399:  int lines_cleared = 0;
       21:  400:  for (int y = 0; y < HEIGHT; y++) {
       20:  401:    bool complete = true;
      20*:  402:    for (int x = 0; x < WIDTH; x++) {
       20:  403:      if (s->game.field[y][x] == 0) {
       20:  404:        complete = false;
       20:  405:        break;
        -:  406:      }
        -:  407:    }
       20:  408:    if (complete) {
    #####:  409:      clear_lines(y);
    #####:  410:      lines_cleared++;
    #####:  411:      y--;  // Проверяем ту же строку ещё раз, так как она теперь заполнена
        -:  412:            // строкой выше
        -:  413:    }
        -:  414:  }
        1:  415:  s->game.score += lines_cleared_score(lines_cleared);
        1:  416:  s->state = SPAWN;
        1:  417:}
        1:  418:int lines_cleared_score(int lines_cleared){
        1:  419:    switch (lines_cleared) {
    #####:  420:    case 1:
    #####:  421:     return 100;
        -:  422:      break;
    #####:  423:    case 2:
    #####:  424:      return 300;
        -:  425:      break;
    #####:  426:    case 3:
    #####:  427:      return 700;
        -:  428:      break;
    #####:  429:    case 4:
    #####:  430:      return 1500;
        -:  431:      break;
        1:  432:    default:
        1:  433:      return 0;
        -:  434:  }
        -:  435:}
        -:  436:
        1:  437:void clear_lines(int line) {
        1:  438:  Singleton *s = get_instance();
        5:  439:  for (int y = line; y > 0; y--) {
       44:  440:    for (int x = 0; x < WIDTH; x++) {
       40:  441:      s->game.field[y][x] = s->game.field[y - 1][x];
        -:  442:    }
        -:  443:  }
       11:  444:  for (int x = 0; x < WIDTH; x++) {
       10:  445:    s->game.field[0][x] = 0;
        -:  446:  }
        1:  447:}
        2:  448:void change_speed() {
        2:  449:  Singleton *s = get_instance();
        2:  450:  int speed_levels[] = {7200, 6400, 5600, 4800, 4000,
        -:  451:                        3200, 2400, 1600, 800,  200};
        2:  452:  int score_thresholds[] = {600,  1200, 1800, 2400, 3000,
        -:  453:                            3600, 4200, 4800, 5400, 6000};
        2:  454:  int num_levels = sizeof(speed_levels) / sizeof(speed_levels[0]);
       22:  455:  for (int i = num_levels - 1; i >= 0; i--) {
       20:  456:    if (s->game.score >= score_thresholds[i]) {
    #####:  457:      s->game.speed = speed_levels[i];
    #####:  458:      s->game.level = i + 1;
    #####:  459:      break;
        -:  460:    }
        -:  461:  }
        2:  462:}
       13:  463:void userInput(UserAction_t action, bool hold) {
        -:  464:  (void)hold;
       13:  465:  Singleton *s = get_instance();
       13:  466:  switch (action) {
        1:  467:    case Left:
        1:  468:      move_piece_left();
        1:  469:      update_field(s->game);
        1:  470:      break;
        1:  471:    case Right:
        1:  472:      move_piece_right();
        1:  473:      update_field(s->game);
        1:  474:      break;
        3:  475:    case Down:
        3:  476:      if (s->state == MOVING) {
       20:  477:        while (s->state != ATTACHING) move_piece_down();
        1:  478:        update_field(s->game);
        -:  479:      }
        3:  480:      break;
        1:  481:    case Up:
        1:  482:      move_piece_up();
        1:  483:      break;
        1:  484:    case Action:
        1:  485:      rotate_piece();
        1:  486:      update_field(s->game);
        1:  487:      break;
        1:  488:    case Pause:
        1:  489:      s->game.pause = !(s->game.pause);
        1:  490:      break;
    #####:  491:    case Start:
    #####:  492:      free_game_resources();
    #####:  493:      free_singleton();
    #####:  494:      tetris_start();
    #####:  495:      break;
        1:  496:    case Terminate:
        1:  497:      s->state = GAME_OVER;
        1:  498:      break;
        -:  499:  }
       13:  500:}
        -:  501:
       13:  502:UserAction_t keyboard_action(int *ch, int *pocket, bool *hold, bool test) {
       13:  503:    Singleton * s =  get_instance();
       13:  504:    if (!test)
        6:  505:    *ch = GET_USER_INPUT;
       13:  506:  *hold = (*pocket == *ch) ? true : false;
       13:  507:  *pocket = *ch;
       13:  508:  if (s->test==1) {*ch = KEY_DOWN;
        2:  509:  s->game.speed=0;}
       13:  510:  switch (*ch) {
        1:  511:    case KEY_LEFT:
        1:  512:      return Left;
        1:  513:    case KEY_RIGHT:
        1:  514:      return Right;
        3:  515:    case KEY_DOWN:
        3:  516:      return Down;
    #####:  517:    case KEY_UP:
    #####:  518:      return Up;
        1:  519:    case ' ':
        1:  520:      return Action;
        1:  521:    case 'p':
        1:  522:      return Pause;
        1:  523:    case 's':
        1:  524:      return Start;
        1:  525:    case 'q':
        1:  526:      return Terminate;
        4:  527:    default:
        4:  528:      return ERR;
        -:  529:  }
        -:  530:}
