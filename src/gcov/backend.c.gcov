        -:    0:Source:brick_game/tetris/backend.c
        -:    1:#include "backend.h"
        -:    2:
        -:    3:#include "../../gui/cli/frontend.h"
        -:    4:
        -:    5:static FSMState transitionMatrix[NUM_STATES][8] = {
        -:    6:    [START] = {[Start] = SPAWN,
        -:    7:               [Terminate] = GAME_OVER,
        -:    8:               [Pause] = START,
        -:    9:               [Left] = START,
        -:   10:               [Right] = START,
        -:   11:               [Up] = START,
        -:   12:               [Down] = START,
        -:   13:               [Action] = START},
        -:   14:    [SPAWN] = {[Action] = MOVING,
        -:   15:               [Terminate] = GAME_OVER,
        -:   16:               [Pause] = SPAWN,
        -:   17:               [Left] = SPAWN,
        -:   18:               [Right] = SPAWN,
        -:   19:               [Up] = SPAWN,
        -:   20:               [Down] = SPAWN,
        -:   21:               [Start] = SPAWN},
        -:   22:    [MOVING] = {[Action] = SHIFTING,
        -:   23:                [Terminate] = GAME_OVER,
        -:   24:                [Pause] = MOVING,
        -:   25:                [Left] = MOVING,
        -:   26:                [Right] = MOVING,
        -:   27:                [Up] = MOVING,
        -:   28:                [Down] = MOVING,
        -:   29:                [Start] = MOVING},
        -:   30:    [SHIFTING] = {[Action] = SHIFTING,
        -:   31:                  [Terminate] = GAME_OVER,
        -:   32:                  [Pause] = MOVING,
        -:   33:                  [Left] = MOVING,
        -:   34:                  [Right] = MOVING,
        -:   35:                  [Up] = MOVING,
        -:   36:                  [Down] = MOVING,
        -:   37:                  [Start] = START},
        -:   38:    [ATTACHING] = {[Action] = SPAWN,
        -:   39:                   [Terminate] = GAME_OVER,
        -:   40:                   [Pause] = ATTACHING,
        -:   41:                   [Left] = ATTACHING,
        -:   42:                   [Right] = ATTACHING,
        -:   43:                   [Up] = ATTACHING,
        -:   44:                   [Down] = ATTACHING,
        -:   45:                   [Start] = ATTACHING},
        -:   46:    [GAME_OVER] = {[Action] = GAME_OVER,
        -:   47:                   [Terminate] = GAME_OVER,
        -:   48:                   [Pause] = GAME_OVER,
        -:   49:                   [Left] = GAME_OVER,
        -:   50:                   [Right] = GAME_OVER,
        -:   51:                   [Up] = GAME_OVER,
        -:   52:                   [Down] = GAME_OVER,
        -:   53:                   [Start] = START}};
        -:   54:
        -:   55:
        2:   56:int play_tetris(int ch) {
        2:   57:  Singleton * s =get_instance();
        2:   58:  s->test = (ch == 1) ? 0 : 1;
        2:   59:  clear();
        2:   60:  int menu_start_x = (WIDTH * 2) / 2 - 3;
        2:   61:  int menu_start_y = HEIGHT / 2 - 2 / 2;
        2:   62:  draw_board();
        2:   63:  int high_score = read_high_score();
        2:   64:  draw_score(0, high_score, 0);
        2:   65:  int x_cooord = 17;
        2:   66:  mvprintw(menu_start_y, menu_start_x - 1, "Tetris game");
        2:   67:  mvprintw(menu_start_y + 2, menu_start_x - 5, "Press \"S\" for Start");
        2:   68:  mvprintw(menu_start_y - 1, menu_start_x + x_cooord, "Press \"P\" for Pause");
        2:   69:  mvprintw(menu_start_y + 1, menu_start_x + x_cooord,
        -:   70:           "Press \"Down\" for Down");
        2:   71:  mvprintw(menu_start_y + 3, menu_start_x + x_cooord,
        -:   72:           "Press \"Left\" for Left");
        2:   73:  mvprintw(menu_start_y + 5, menu_start_x + x_cooord,
        -:   74:           "Press \"Right\" for Right");
        2:   75:  mvprintw(menu_start_y + 7, menu_start_x + x_cooord,
        -:   76:           "Press \"Space\" for Action");
        2:   77:  mvprintw(menu_start_y + 9, menu_start_x + x_cooord, "Press \"Q\" for Quit");
       2*:   78:  while (ch != 'S' && ch != 's') {
    #####:   79:    ch = GET_USER_INPUT;
        -:   80:  }
        2:   81:  int res = tetris_start();
        2:   82:  if (s->test!=1){
    #####:   83:  game_over_menu();
        -:   84: }
        2:   85:  free_game_resources();
        2:   86:  free_singleton();
        2:   87:  return res;
        -:   88:}
        -:   89:
        2:   90:int tetris_start() {
        2:   91:  int res = 0;
        2:   92:  Singleton *s = get_instance();
        2:   93:  s->state = SPAWN;
        2:   94:  res = initialize_game();
        2:   95:  int ch = '\0';
        2:   96:  int pocket = '\0';
        2:   97:  bool hold = false;
        2:   98:  clock_t last_update_time = clock();
        2:   99:  nodelay(stdscr, TRUE);
        4:  100:  while (s->state != GAME_OVER) {
        2:  101:    change_speed();
        2:  102:    clock_t current_time = clock();
        2:  103:    if (tet_timer(&current_time, &last_update_time, s->game.speed)) {
    #####:  104:      if (!s->game.pause) {
    #####:  105:        update_field(updateCurrentState());
        -:  106:      }
    #####:  107:      last_update_time = current_time;
        -:  108:    }
        2:  109:    userInput(keyboard_action(&ch, &pocket, &hold, false), hold);
        2:  110:    refresh();
        2:  111:    if (s->test==1) s->state=GAME_OVER;
        -:  112:  }
        2:  113:  nodelay(stdscr, FALSE);
        2:  114:  return res;
        -:  115:}
        -:  116:
        4:  117:GameInfo_t updateCurrentState() {
        4:  118:  Singleton *s = get_instance();
        4:  119:  int ch = '\0';
        4:  120:  bool hold = false;
        4:  121:  int pocket = '\0';
        4:  122:  s->action = keyboard_action(&ch, &pocket, &hold, false);
        4:  123:  userInput(s->action, hold);
        4:  124:  if (s->action > 0 && s->action <= 8) {
    #####:  125:    s->state = transitionMatrix[s->state][s->action];
        -:  126:  }
        4:  127:  switch (s->state) {
        1:  128:    case SPAWN:
        1:  129:      init_piece();
        1:  130:      s->state = MOVING;
        1:  131:      break;
        1:  132:    case MOVING:
        1:  133:      move_piece_down();
        1:  134:      s->state= MOVING;
        1:  135:      break;
        1:  136:    case ATTACHING:
        1:  137:      if (check_collision_end_game()) {
    #####:  138:        s->state= GAME_OVER;
        -:  139:      } else {
        1:  140:        attach_piece_to_field();
        1:  141:        check_for_complete_lines();
        1:  142:        s->state= SPAWN;
        -:  143:      }
        1:  144:      break;
        1:  145:    default:
        1:  146:      break;
        -:  147:  }
        4:  148:  return s->game;
        -:  149:}
        -:  150:
        7:  151:int initialize_game() {
        7:  152:  int res = 0;
        7:  153:  Singleton *s = get_instance();
        7:  154:  s->game.field = (int **)calloc(HEIGHT, sizeof(int *));
        7:  155:  if (!s->game.field) {
    #####:  156:    perror("Failed to allocate memory for game.field");
    #####:  157:    res++;
        -:  158:  }
      147:  159:  for (int i = 0; i < HEIGHT && !res; i++) {
      140:  160:    s->game.field[i] = (int *)calloc(WIDTH, sizeof(int));
      140:  161:    if (!s->game.field[i]) {
    #####:  162:      perror("Failed to allocate memory for game.field[i]");
    #####:  163:      res++;
        -:  164:    }
        -:  165:  }
        7:  166:  if (!res) {
        7:  167:    s->game.next = (int **)calloc(4, sizeof(int *));
        7:  168:    if (!s->game.next) {
    #####:  169:      perror("Failed to allocate memory for game.next");
    #####:  170:      res++;
        -:  171:    }
       35:  172:    for (int i = 0; i < 4 && !res; i++) {
       28:  173:      s->game.next[i] = (int *)calloc(4, sizeof(int));
       28:  174:      if (!s->game.next[i]) {
    #####:  175:        perror("Failed to allocate memory for game.next[i]");
    #####:  176:        res++;
        -:  177:      }
        -:  178:    }
        -:  179:  }
        7:  180:  s->game.score = 0;
        7:  181:  s->game.high_score = read_high_score();
        7:  182:  s->game.level = 0;
        7:  183:  s->game.speed = 8000;
        7:  184:  init_piece();
        7:  185:  return res;
        -:  186:}
        -:  187:
        2:  188:bool tet_timer(clock_t *current_time, clock_t *last_update_time, int speed) {
        2:  189:  return (((*current_time - *last_update_time) * 10000 / CLOCKS_PER_SEC) >=
        -:  190:          speed);
        -:  191:}
        -:  192:
        -:  193:
        3:  194:void free_game_resources() {
        3:  195:  Singleton *s = get_instance();
        3:  196:  if (s->game.field != NULL) {
       42:  197:    for (int i = 0; i < HEIGHT; i++) {
       40:  198:      if (s->game.field[i] != NULL) {
       40:  199:        free(s->game.field[i]);
        -:  200:      }
        -:  201:    }
        2:  202:    free(s->game.field);
        2:  203:    s->game.field = NULL;
        -:  204:  }
        3:  205:  if (s->game.next != NULL) {
       10:  206:    for (int i = 0; i < 4; i++) {
        8:  207:      if (s->game.next[i] != NULL) {
        8:  208:        free(s->game.next[i]);
        -:  209:      }
        -:  210:    }
        2:  211:    free(s->game.next);
        2:  212:    s->game.next = NULL;
        -:  213:  }
        3:  214:}
        8:  215:void init_piece() {
        8:  216:  Singleton *s = get_instance();
        -:  217:  struct timespec tv;
        8:  218:  clock_gettime(CLOCK_MONOTONIC, &tv);
        8:  219:  unsigned int seed = tv.tv_sec * 1000000 + tv.tv_nsec / 1000;
        8:  220:  srand(seed);
        -:  221:  // Инициализация новой фигуры в верхней части экрана
        8:  222:  s->current_piece.x = WIDTH / 2 - 2;
        8:  223:  s->current_piece.y = 0;
        -:  224:  // Определение различных форм фигур
        8:  225:  int shapes[7][4][4] = SHAPES;
        -:  226:  // Инициализация генератора случайных чисел
        8:  227:  srand(time(NULL));
        8:  228:  int shape_next = rand() % 7;
       40:  229:  for (int i = 0; i < 4; i++) {
      160:  230:    for (int j = 0; j < 4; j++) {
      128:  231:      s->game.next[i][j] = shapes[shape_next][i][j];
        -:  232:    }
        -:  233:  }
        8:  234:  if (s->shape_curr == -1) {
        7:  235:    s->shape_curr = rand() % 7;
        -:  236:  }
        8:  237:  memcpy(s->current_piece.shape, shapes[s->shape_curr],
        -:  238:         sizeof(shapes[s->shape_curr]));
        8:  239:  s->current_piece.type = s->shape_curr;
        8:  240:  s->shape_curr = shape_next;
        8:  241:}
        -:  242:
       21:  243:void move_piece_down() {
       21:  244:  Singleton *s = get_instance();
       21:  245:  s->current_piece.y++;
       21:  246:  if (check_collision()) {
        1:  247:    s->current_piece.y--;
        1:  248:    s->state = ATTACHING;
        -:  249:  }
       21:  250:}
        2:  251:void move_piece_left() {
        2:  252:  Singleton *s = get_instance();
        2:  253:  if (s->state == MOVING) {
        1:  254:    s->current_piece.x--;
        1:  255:    if (check_collision()) {
    #####:  256:      s->current_piece.x++;
        -:  257:    }
        -:  258:  }
        2:  259:}
        -:  260:
        2:  261:void move_piece_right() {
        2:  262:  Singleton *s = get_instance();
        2:  263:  if (s->state == MOVING) {
        1:  264:    s->current_piece.x++;
        1:  265:    if (check_collision()) {
    #####:  266:      s->current_piece.x--;
        -:  267:    }
        -:  268:  }
        2:  269:}
        -:  270:
        1:  271:void move_piece_up() {}
        -:  272:
        3:  273:void rotate_piece() {
        3:  274:  Singleton *s = get_instance();
        3:  275:  if (s->state == MOVING && s->current_piece.type != 1) {
        1:  276:    int temp_shape[4][4] = {0};
        -:  277:    // Транспонируем матрицу
        5:  278:    for (int y = 0; y < 4; y++) {
       20:  279:      for (int x = 0; x < 4; x++) {
       16:  280:        temp_shape[x][y] = s->current_piece.shape[y][x];
        -:  281:      }
        -:  282:    }
        -:  283:    // Отражаем матрицу по вертикали
        5:  284:    for (int y = 0; y < 4; y++) {
       20:  285:      for (int x = 0; x < 4; x++) {
       16:  286:        s->current_piece.shape[x][y] = temp_shape[x][3 - y];
        -:  287:      }
        -:  288:    }
        -:  289:    // Проверка коллизий
        1:  290:    if (check_collision()) {
        -:  291:      // Попробуем сдвинуть фигуру, чтобы она не застревала в стене
    #####:  292:      bool collision = true;
    #####:  293:      for (int dx = -1; dx <= 1 && collision; dx++) {
    #####:  294:        for (int dy = -1; dy <= 1 && collision; dy++) {
    #####:  295:          s->current_piece.x += dx;
    #####:  296:          s->current_piece.y += dy;
    #####:  297:          if (!check_collision()) {
    #####:  298:            collision = false;
    #####:  299:            break;
        -:  300:          }
    #####:  301:          s->current_piece.x -= dx;
    #####:  302:          s->current_piece.y -= dy;
        -:  303:        }
        -:  304:      }
        -:  305:      // Если не удалось избежать коллизий, проверим границы и скорректируем
    #####:  306:      if (collision) {
        -:  307:        // Корректируем положение фигуры относительно границ поля
    #####:  308:        for (int x = 0; x < 4; x++) {
    #####:  309:          for (int y = 0; y < 4; y++) {
    #####:  310:            if (s->current_piece.shape[y][x] != 0) {
    #####:  311:              if (s->current_piece.x + x < 0) {
    #####:  312:                s->current_piece.x++;
        -:  313:              }
    #####:  314:              if (s->current_piece.x + x >= WIDTH) {
    #####:  315:                s->current_piece.x--;
        -:  316:              }
    #####:  317:              if (s->current_piece.y + y >= HEIGHT) {
    #####:  318:                s->current_piece.y--;
        -:  319:              }
        -:  320:            }
        -:  321:          }
        -:  322:        }
        -:  323:        // Повторная проверка коллизий после корректировки
    #####:  324:        if (check_collision()) {
        -:  325:          // Попробуем переместить фигуру только по горизонтали
    #####:  326:          for (int dx = -2; dx <= 2 && collision; dx++) {
    #####:  327:            s->current_piece.x += dx;
    #####:  328:            if (!check_collision()) {
    #####:  329:              collision = false;
    #####:  330:              break;
        -:  331:            }
    #####:  332:            s->current_piece.x -= dx;
        -:  333:          }
        -:  334:          // Если все еще не удалось избежать коллизий, отменяем поворот
    #####:  335:          if (collision) {
    #####:  336:            for (int y = 0; y < 4; y++) {
    #####:  337:              for (int x = 0; x < 4; x++) {
    #####:  338:                s->current_piece.shape[y][x] = temp_shape[y][x];
        -:  339:              }
        -:  340:            }
        -:  341:          }
        -:  342:        }
        -:  343:      }
        -:  344:    }
        -:  345:  }
        3:  346:}
       25:  347:bool check_collision() {
       25:  348:  Singleton *s = get_instance();
      122:  349:  for (int y = 0; y < 4; y++) {
      486:  350:    for (int x = 0; x < 4; x++) {
      389:  351:      if (s->current_piece.shape[y][x] != 0) {
       83:  352:        int new_y = s->current_piece.y + y;
       83:  353:        int new_x = s->current_piece.x + x;
       83:  354:        if (new_y >= HEIGHT || new_x < 0 || new_x >= WIDTH ||
       82:  355:            s->game.field[new_y][new_x] != 0) {
        1:  356:          return true;
        -:  357:        }
        -:  358:      }
        -:  359:    }
        -:  360:  }
       24:  361:  return false;
        -:  362:}
        2:  363:bool check_collision_end_game() {
        2:  364:  Singleton *s = get_instance();
       10:  365:  for (int y = 0; y < 4; y++) {
       40:  366:    for (int x = 0; x < 4; x++) {
       32:  367:      if (s->current_piece.shape[y][x] != 0) {
        4:  368:        int new_y = s->current_piece.y + y;
        4:  369:        int new_x = s->current_piece.x + x;
        -:  370:        // Проверка на выход за границы поля
       4*:  371:        if (new_y >= HEIGHT || new_x < 0 || new_x >= WIDTH) {
    #####:  372:          continue;
        -:  373:        }
        -:  374:        // Проверка на столкновение с уже существующими фигурами
        4:  375:        if (s->game.field[new_y][new_x] != 0) {
    #####:  376:          return true;
        -:  377:        }
        -:  378:      }
        -:  379:    }
        -:  380:  }
        2:  381:  return false;
        -:  382:}
        2:  383:void attach_piece_to_field() {
        2:  384:  Singleton *s = get_instance();
       10:  385:  for (int y = 0; y < 4; y++) {
       40:  386:    for (int x = 0; x < 4; x++) {
       32:  387:      if (s->current_piece.shape[y][x] != 0) {
        4:  388:        int field_y = s->current_piece.y + y;
        4:  389:        int field_x = s->current_piece.x + x;
        4:  390:        if (field_y >= 0 && field_y < HEIGHT && field_x >= 0 &&
        -:  391:            field_x < WIDTH) {
        4:  392:          s->game.field[field_y][field_x] = s->current_piece.shape[y][x];
        -:  393:        }
        -:  394:      }
        -:  395:    }
        -:  396:  }
        2:  397:}
        -:  398:
        1:  399:void check_for_complete_lines() {
        1:  400:  Singleton *s = get_instance();
        1:  401:  int lines_cleared = 0;
       21:  402:  for (int y = 0; y < HEIGHT; y++) {
       20:  403:    bool complete = true;
      20*:  404:    for (int x = 0; x < WIDTH; x++) {
       20:  405:      if (s->game.field[y][x] == 0) {
       20:  406:        complete = false;
       20:  407:        break;
        -:  408:      }
        -:  409:    }
       20:  410:    if (complete) {
    #####:  411:      clear_lines(y);
    #####:  412:      lines_cleared++;
    #####:  413:      y--;  // Проверяем ту же строку ещё раз, так как она теперь заполнена
        -:  414:            // строкой выше
        -:  415:    }
        -:  416:  }
        1:  417:  s->game.score += lines_cleared_score(lines_cleared);
        1:  418:  s->state = SPAWN;
        1:  419:}
        1:  420:int lines_cleared_score(int lines_cleared){
        1:  421:    switch (lines_cleared) {
    #####:  422:    case 1:
    #####:  423:     return 100;
        -:  424:      break;
    #####:  425:    case 2:
    #####:  426:      return 300;
        -:  427:      break;
    #####:  428:    case 3:
    #####:  429:      return 700;
        -:  430:      break;
    #####:  431:    case 4:
    #####:  432:      return 1500;
        -:  433:      break;
        1:  434:    default:
        1:  435:      return 0;
        -:  436:  }
        -:  437:}
        -:  438:
        1:  439:void clear_lines(int line) {
        1:  440:  Singleton *s = get_instance();
        5:  441:  for (int y = line; y > 0; y--) {
       44:  442:    for (int x = 0; x < WIDTH; x++) {
       40:  443:      s->game.field[y][x] = s->game.field[y - 1][x];
        -:  444:    }
        -:  445:  }
       11:  446:  for (int x = 0; x < WIDTH; x++) {
       10:  447:    s->game.field[0][x] = 0;
        -:  448:  }
        1:  449:}
        2:  450:void change_speed() {
        2:  451:  Singleton *s = get_instance();
        2:  452:  int speed_levels[] = {7200, 6400, 5600, 4800, 4000,
        -:  453:                        3200, 2400, 1600, 800,  200};
        2:  454:  int score_thresholds[] = {600,  1200, 1800, 2400, 3000,
        -:  455:                            3600, 4200, 4800, 5400, 6000};
        2:  456:  int num_levels = sizeof(speed_levels) / sizeof(speed_levels[0]);
       22:  457:  for (int i = num_levels - 1; i >= 0; i--) {
       20:  458:    if (s->game.score >= score_thresholds[i]) {
    #####:  459:      s->game.speed = speed_levels[i];
    #####:  460:      s->game.level = i + 1;
    #####:  461:      break;
        -:  462:    }
        -:  463:  }
        2:  464:}
       14:  465:void userInput(UserAction_t action, bool hold) {
        -:  466:  (void)hold;
       14:  467:  Singleton *s = get_instance();
       14:  468:  switch (action) {
        1:  469:    case Left:
        1:  470:      move_piece_left();
        1:  471:      update_field(s->game);
        1:  472:      break;
        1:  473:    case Right:
        1:  474:      move_piece_right();
        1:  475:      update_field(s->game);
        1:  476:      break;
        3:  477:    case Down:
        3:  478:      if (s->state == MOVING) {
       20:  479:        while (s->state != ATTACHING) move_piece_down();
        1:  480:        update_field(s->game);
        -:  481:      }
        3:  482:      break;
        1:  483:    case Up:
        1:  484:      move_piece_up();
        1:  485:      break;
        1:  486:    case Action:
        1:  487:      rotate_piece();
        1:  488:      update_field(s->game);
        1:  489:      break;
        1:  490:    case Pause:
        1:  491:      s->game.pause = !(s->game.pause);
        1:  492:      break;
        1:  493:    case Start:
        1:  494:      if (s->state==GAME_OVER){
    #####:  495:      free_game_resources();
    #####:  496:      free_singleton();
    #####:  497:      tetris_start();}
        1:  498:      break;
        1:  499:    case Terminate:
        1:  500:      s->state = GAME_OVER;
        1:  501:      break;
        -:  502:  }
       14:  503:}
        -:  504:
       13:  505:UserAction_t keyboard_action(int *ch, int *pocket, bool *hold, bool test) {
       13:  506:    Singleton * s =  get_instance();
       13:  507:    if (!test)
        6:  508:    *ch = GET_USER_INPUT;
       13:  509:  *hold = (*pocket == *ch) ? true : false;
       13:  510:  *pocket = *ch;
       13:  511:  if (s->test==1) {*ch = KEY_DOWN;
        2:  512:  s->game.speed=0;}
       13:  513:  switch (*ch) {
        1:  514:    case KEY_LEFT:
        1:  515:      return Left;
        1:  516:    case KEY_RIGHT:
        1:  517:      return Right;
        3:  518:    case KEY_DOWN:
        3:  519:      return Down;
    #####:  520:    case KEY_UP:
    #####:  521:      return Up;
        1:  522:    case ' ':
        1:  523:      return Action;
        1:  524:    case 'p':
        1:  525:      return Pause;
        1:  526:    case 's':
        1:  527:      return Start;
        1:  528:    case 'q':
        1:  529:      return Terminate;
        4:  530:    default:
        4:  531:      return ERR;
        -:  532:  }
        -:  533:}
